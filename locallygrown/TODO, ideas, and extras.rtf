{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red93\green108\blue121;\red255\green255\blue255;\red0\green0\blue0;
\red14\green14\blue255;}
{\*\expandedcolortbl;;\csgenericrgb\c36526\c42188\c47515;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0\c85000;
\csgenericrgb\c5500\c5500\c100000;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Abstract cart, and other complex models from the user object\
Additional service for delivery/pickup options\
Follow tutorial here: https://www.swiftbysundell.com/articles/handling-loading-states-in-swiftui/ -> to abstract loading states\
\
Product Ideas:\
delivery for large orders\
how to deliver from multiple locations at once?\
\
Look into uber connect:\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1 \cf2 \cb3 /*func getUberAuth() \{\cf4 \
\cf2         guard let url = URL(string: "\cf5 https://login.uber.com/oauth/v2/token\cf2 ") else \{ return \}\cf4 \
\cf2         var req = URLRequest(url: url)\cf4 \
\cf2         req.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")\cf4 \
\cf2         //req.setValue("application/json", forHTTPHeaderField: "Accept")\cf4 \
\cf2         req.httpMethod = "POST"\cf4 \
\cf2         let parameters: [String: Any] = [\cf4 \
\cf2             "client_id": "0wbt00fOroCuUQqJVXLDVPuJ3DAPyp_e",\cf4 \
\cf2             "client_secret": "HvJq3ISsw9iLAXIP1JeY0mH8h4IgjsgjqmC-nvK_",\cf4 \
\cf2             "grant_type": "client_credentials",\cf4 \
\cf2             "scope":"eats.deliveries"\cf4 \
\cf2         ]\cf4 \
\cf2         //req.httpBody = parameters\cf4 \
\cf2         \cf4 \
\cf2         do \{\cf4 \
\cf2             // convert parameters to Data and assign dictionary to httpBody of request\cf4 \
\cf2             req.httpBody = try JSONSerialization.data(withJSONObject: parameters, options: .prettyPrinted)\cf4 \
\cf2         \} catch let error \{\cf4 \
\cf2             print(error.localizedDescription)\cf4 \
\cf2             return\cf4 \
\cf2         \}\cf4 \
\cf2         \cf4 \
\cf2         let task = URLSession.shared.dataTask(with: req) \{ data, response, error in\cf4 \
\cf2             guard\cf4 \
\cf2                 let data = data,\cf4 \
\cf2                 let response = response as? HTTPURLResponse,\cf4 \
\cf2                 error == nil\cf4 \
\cf2             else \{                                                               // check for fundamental networking error\cf4 \
\cf2                 print("error", error ?? URLError(.badServerResponse))\cf4 \
\cf2                 return\cf4 \
\cf2             \}\cf4 \
\cf2             print(data)\cf4 \
\cf2             guard (200 ... 299) ~= response.statusCode else \{                    // check for http errors\cf4 \
\cf2                 print("statusCode should be 2xx, but is \\(response.statusCode)")\cf4 \
\cf2                 print("response = \\(response)")\cf4 \
\cf2                 return\cf4 \
\cf2             \}\cf4 \
\cf2             \cf4 \
\cf2             // do whatever you want with the `data`, e.g.:\cf4 \
\cf2             \cf4 \
\cf2             //do \{\cf4 \
\cf2                 //let responseObject = try JSONDecoder().decode(ResponseObject<Foo>.self, from: data)\cf4 \
\cf2             print("no problem")\cf4 \
\cf2             /*\} catch \{\cf4 \
\cf2                 print(error) // parsing error\cf4 \
\cf2                 \cf4 \
\cf2                 if let responseString = String(data: data, encoding: .utf8) \{\cf4 \
\cf2                     print("responseString = \\(responseString)")\cf4 \
\cf2                 \} else \{\cf4 \
\cf2                     print("unable to parse response as string")\cf4 \
\cf2                 \}\cf4 \
\cf2             \}*/\cf4 \
\cf2         \}\cf4 \
\
\cf2         task.resume()\cf4 \
\cf2     \}*/}